# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    main.c.old                                         :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: vboissel <vboissel@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2018/10/24 17:24:13 by vboissel          #+#    #+#              #
#    Updated: 2019/01/16 14:59:51 by vboissel         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include "header.h"
#include <stdio.h>
#include <math.h>

#define mapWidth 24
#define mapHeight 24


int		main(char *argc, char *argv)
{
	
	return (0);
}




void				fdf_fill_image(t_image *image, unsigned int color)
{
	size_t	img_size;
	size_t	i;

	img_size = WIDTH * HEIGHT;
	i = 0;
	while (i < img_size)
	{
		image->img[i] = color;
		i++;
	}
}

void                    fdf_put_pixel(t_image *image, unsigned int color,
                                int x, int y)
{
        image->img[y * WIDTH + x] = color;
}

unsigned int		to_color(unsigned int r, unsigned int g,
	unsigned int b, unsigned int a)
{
	unsigned int argb;

	argb = (
		(((a > 0xff) ? 0xff : a) << 24) |
		(((r > 0xff) ? 0xff : r) << 16) |
		(((g > 0xff) ? 0xff : g) << 8) |
		(((b > 0xff) ? 0xff : b)));
	return (argb);
}

static void			fdf_bresenham(t_image *img, t_vector2l strt,
			t_vector2l end, unsigned int color)
{
	t_vector2l	s;
	t_vector2l	d;
	int			err;
	int			err_2;

	d.x = abs(end.x - strt.x);
	d.y = abs(end.y - strt.y);
	s.x = strt.x < end.x ? 1 : -1;
	s.y = strt.y < end.y ? 1 : -1;
	err = (d.x > d.y ? d.x : -d.y) / 2;
	while (strt.x != end.x && strt.y != end.y)
	{
		if (strt.x > 0 && strt.y > 0 && strt.x < WIDTH && strt.y < HEIGHT)
			fdf_put_pixel(img, color, strt.x, strt.y);
		err_2 = err;
		err = (err_2 > -d.x) ? err - d.y : err;
		strt.x = (err_2 > -d.x) ? strt.x + s.x : strt.x;
		err = (err_2 < d.y) ? err + d.x : err;
		strt.y = (err_2 < d.y) ? strt.y + s.y : strt.y;
	}
}

static void			fdf_vertical(t_image *img, t_vector2l strt,
	t_vector2l end, unsigned int color)
{
	t_vector2l swp;

	if (strt.y > end.y)
	{
		swp = strt;
		strt = end;
		end = swp;
	}
	while (strt.y <= end.y)
	{
		if (strt.y > 0 && strt.y < HEIGHT)
			fdf_put_pixel(img, color, strt.x, strt.y);
		strt.y += 1;
	}
}

static void			fdf_horizontal(t_image *img, t_vector2l strt,
	t_vector2l end, unsigned int color)
{
	t_vector2l swp;

	if (strt.x > end.x)
	{
		swp = strt;
		strt = end;
		end = swp;
	}
	while (strt.x <= end.x)
	{
		if (strt.x > 0 && strt.x < HEIGHT)
			fdf_put_pixel(img, color, strt.x, strt.y);
		strt.x += 1;
	}
}

void				fdf_draw_line(t_image *img, t_vector2l strt,
						t_vector2l end, unsigned int color)
{
	if (strt.x == end.x)
		fdf_vertical(img, strt, end, color);
	if (strt.y == end.y)
		fdf_horizontal(img, strt, end, color);
	if ((strt.x != end.x) && (strt.y != end.y))
		fdf_bresenham(img, strt, end, color);
}

t_image			*fdf_create_image(void* mlx_ptr)
{
	t_image	*image;

	if ((image = ft_memalloc(sizeof(t_image))) == NULL)
		return (NULL);
	if (!(image->img_ptr = mlx_new_image(mlx_ptr, WIDTH, HEIGHT)))
		return (NULL);
	if (!(image->img = (unsigned int *)mlx_get_data_addr(
			image->img_ptr,
			&image->bpp,
			&image->size_line,
			&image->endian)))
		return (NULL);
	fdf_fill_image(image, to_color(0, 0, 0, 0));
	return (image);
}

t_vector2i		set_vec2i(int x, int y)
{
	return ((t_vector2i){x, y});
}

t_vector2d		set_vec2d(double x, double y)
{
	return ((t_vector2d){x, y});
}

t_env			*init_mlx(void)
{
	t_env	*e;

	if (!(e = ft_memalloc(sizeof(t_env))))
		return (NULL);
	if (!(e->mlx_ptr = mlx_init()))
		return (NULL);
	if (!(e->win_ptr = mlx_new_window(e->mlx_ptr, WIDTH, HEIGHT, "Fractol")))
		return (NULL);
	return (e);
}


int		renderer(int wm[24][24], t_vector2d dir, t_vector2d plane, t_vector2d pos, void* mlx_ptr, void *win_ptr)
{
	int 		x; 
	t_vector2i	map;
	t_vector2i	step;
	t_vector2d	sideDist;
	t_vector2d	deltaDist;
	double		perpWallDist;
	int			hit;
	int			side;
	t_image		*img;

	img = fdf_create_image(mlx_ptr);

	x = 0;
	while (x < WIDTH)
	{
		double cameraX = 2 * x / (double)WIDTH - 1; 
    	double rayDirX = dir.x + plane.x * cameraX;
    	double rayDirY = dir.y + plane.y * cameraX;
		map = set_vec2i(pos.x, pos.y);
		deltaDist = set_vec2d(fabs(1 / rayDirX), fabs(1 / rayDirY));
		hit = 0;
    	if (rayDirX < 0)
		{
			step.x = -1;
			sideDist.x = (pos.x - map.x) * deltaDist.x;
		}
		else
		{
			step.x = 1;
			sideDist.x = (map.x + 1.0 - pos.x) * deltaDist.x;
		}
		if (rayDirY < 0)
		{
			step.y = -1;
			sideDist.y = (pos.y - map.y) * deltaDist.y;
		}
		else
		{
			step.y = 1;
			sideDist.y = (map.y + 1.0 - pos.y) * deltaDist.y;
		}
		while (hit == 0)
		{
			if (sideDist.x < sideDist.y)
			{
				sideDist.x += deltaDist.x;
				map.x += step.x;
				side = 0;
			}
			else
			{
			sideDist.y += deltaDist.y;
			map.y += step.y;
			side = 1;
			}
			if (wm[map.x][map.y] > 0) hit = 1;
		} 
      	if (side == 0) perpWallDist = (map.x - pos.x + (1 - step.x) / 2) / rayDirX;
     	else           perpWallDist = (map.y - pos.y + (1 - step.y) / 2) / rayDirY;

      	int lineHeight = (int)(HEIGHT / perpWallDist);


		int drawStart = -lineHeight / 2 + HEIGHT / 2;
		if(drawStart < 0)drawStart = 0;
		int drawEnd = lineHeight / 2 + HEIGHT / 2;
		if(drawEnd >= HEIGHT)drawEnd = HEIGHT - 1;
		
		t_vector2l start;

		t_vector2l end;
		start.x = x;
		start.y = drawStart;

		end.x = x;
		end.y = drawEnd;
		fdf_draw_line(img, start, end, to_color(255,0,0,1));
		x++;
	}
	mlx_put_image_to_window(mlx_ptr, win_ptr, img->img_ptr, 0, 0);
	return (0);
}



static void		check_directional_keys(t_env *env, int keycode)
{
	double rotSpeed = 0.04;
	double moveSpeed = 0.4;

	if (keycode == 126)
	{
		if(env->worldMap[(int)(env->pos.x + env->dir.x * moveSpeed)][(int)(env->pos.y)] == 0) 
			env->pos.x += env->dir.x * moveSpeed;
     	if(env->worldMap[(int)(env->pos.x)][(int)(env->pos.y + env->dir.y * moveSpeed)] == 0) 
		 	env->pos.y += env->dir.y * moveSpeed;
	}
	else if (keycode == 125)
	{
		if(env->worldMap[(int)(env->pos.x  - env->dir.x * moveSpeed)][(int)(env->pos.y)] == 0)
			env->pos.x -= env->dir.x * moveSpeed;
    	if(env->worldMap[(int)(env->pos.x )][(int)(env->pos.y - env->dir.y* moveSpeed)] == 0)
	  		env->pos.y -= env->dir.y  * moveSpeed;
	}
	else if (keycode == 124)
	{
		double oldDirX = env->dir.x;
		env->dir.x = env->dir.x * cos(-rotSpeed) - env->dir.y * sin(-rotSpeed);
		env->dir.y = oldDirX * sin(-rotSpeed) + env->dir.y * cos(-rotSpeed);
		double oldPlaneX = env->plane.x;
		env->plane.x = env->plane.x * cos(-rotSpeed) - env->plane.y * sin(-rotSpeed);
		env->plane.y = oldPlaneX * sin(-rotSpeed) + env->plane.y * cos(-rotSpeed);
	}
	else if (keycode == 123)
	{
		double oldDirX = env->dir.x;
		env->dir.x = env->dir.x * cos(rotSpeed) - env->dir.y * sin(rotSpeed);
      	env->dir.y = oldDirX * sin(rotSpeed) + env->dir.y * cos(rotSpeed);
      	double oldPlaneX = env->plane.x ;
      	env->plane.x = env->plane.x * cos(rotSpeed) - env->plane.y * sin(rotSpeed);
      	env->plane.y = oldPlaneX * sin(rotSpeed) + env->plane.y * cos(rotSpeed);
	}
	renderer(env->worldMap, env->dir, env->plane, env->pos, env->mlx_ptr, env->win_ptr);
}

int				key_pressed_hook(int keycode, void *param)
{
	t_env *env;

	printf("keycode : %d\n", keycode);
	env = param;
	check_directional_keys(env, keycode);
	return (0);
}

void			cp_tab(int wm[24][24], t_env *env)
{
	int x = 0;
	int y = 0;
	while (x < 24)
	{
		while (y < 24)
		{
			env->worldMap[x][y] = wm[x][y];
			y++;
		}
		y = 0;
		x++;
	} 
}

int     main(void)
{
    t_env   *env;
	t_vector2d pos;
	t_vector2d dir;
	t_vector2d plane;
	double etime;
	double oldetime;
	int worldMap[mapWidth][mapHeight]=
	{
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,2,2,2,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
	{1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1},
	{1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1},
	{1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1},
	{1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},
	{1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
	{1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};
    env = init_mlx();

	pos.x = 22;
	pos.y = 12;
	dir.x = -1;
	dir.y = 0;
	plane.x = 0;
	plane.y = 0.66;
	etime = 0;
	oldetime = 0;

	env->plane = plane;
	env->pos = pos;
	env->dir = dir;

	cp_tab(worldMap, env);
	renderer(worldMap, dir, plane, pos, env->mlx_ptr, env->win_ptr);
    mlx_hook(env->win_ptr, 2, (1L << 2), &key_pressed_hook, env);
	mlx_loop(env->mlx_ptr);
    return (0);
}
/**/